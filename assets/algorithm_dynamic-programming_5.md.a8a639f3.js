import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.12b7deed.js";const p=JSON.parse('{"title":"最长递增子序列","description":"","frontmatter":{"title":"最长递增子序列","head":[["meta",{"name":"og:title","content":"最长递增子序列 | VitePress"}]]},"headers":[],"relativePath":"algorithm/dynamic-programming/5.md","filePath":"algorithm/dynamic-programming/5.md","lastUpdated":1698918793000}'),o={name:"algorithm/dynamic-programming/5.md"},e=l(`<h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列   是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">输入：nums = [10,9,2,5,3,7,101,18]</span></span>
<span class="line"><span style="color:#e1e4e8;">输出：4</span></span>
<span class="line"><span style="color:#e1e4e8;">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">输入：nums = [10,9,2,5,3,7,101,18]</span></span>
<span class="line"><span style="color:#24292e;">输出：4</span></span>
<span class="line"><span style="color:#24292e;">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span></span></code></pre></div><p>示例 2：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">输入：nums = [0,1,0,3,2,3]</span></span>
<span class="line"><span style="color:#e1e4e8;">输出：4</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">输入：nums = [0,1,0,3,2,3]</span></span>
<span class="line"><span style="color:#24292e;">输出：4</span></span></code></pre></div><p>示例 3：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">输入：nums = [7,7,7,7,7,7,7]</span></span>
<span class="line"><span style="color:#e1e4e8;">输出：1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">输入：nums = [7,7,7,7,7,7,7]</span></span>
<span class="line"><span style="color:#24292e;">输出：1</span></span></code></pre></div><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 2500</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul><p>进阶：</p><p>你能将算法的时间复杂度降低到  O(n log(n)) 吗?</p><h2 id="理解题目" tabindex="-1">理解题目 <a class="header-anchor" href="#理解题目" aria-label="Permalink to &quot;理解题目&quot;">​</a></h2><p>给定一个数组，从数组中寻找递增组成的新数组的长度</p><h2 id="题解" tabindex="-1">题解 <a class="header-anchor" href="#题解" aria-label="Permalink to &quot;题解&quot;">​</a></h2><p>利用当前项去跟当前的前一项去比较，如果 nums[i]&gt;nums[i-1]那么就是递增的 动态规划，从大变小，每个元素都至少可以单独成为子序列，此时长度都为 1 声明数组 dp，dp[i]的值代表 nums[i] 结尾的最长子序列长度：即递增的长度 当我们去比较的是，前面一项之前已经比较过了她也存了之前递增的长度了，依次向前拿去即可 当拿到的前一项的长度+1 和当前项的长度取最大值 赋值给当前项的长度</p><h2 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h2><p>动态规划</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lengthOfLIS</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nums</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 动态规划，从大变小，每个元素都至少可以单独成为子序列，此时长度都为 1</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 声明数组dp，dp[i]的值代表 nums[i] 结尾的最长子序列长度</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> dp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">(nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">fill</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> i; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// num[i]:当前项，nums[j]当前项的前一项</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果nums[i]大于nums[j]，nums[i] 可以接在 nums[j] 之后（因为要求严格递增【排除了相等等情况】），</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 此情况下最长子序列长度为 dp[j] + 1</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// console.log(i,j)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> nums[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// console.log([10, 9, 2, 5, 3, 7, 21, 18], dp);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// console.log(\`i=\${i},nums[\${i}]=\${nums[i]},j=\${j},nums[\${j}]=\${nums[j]},dp[\${i}]=\${dp[i]},dp[\${j}]=\${dp[j]},dp[\${j}] + 1=\${dp[j] + 1}\`);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// console.log(\`因为Math.max(dp[\${i}], dp[\${j}] + 1)所以dp[\${i}]=\${Math.max(dp[i], dp[j] + 1)}\`);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// debugger</span></span>
<span class="line"><span style="color:#E1E4E8;">        dp[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(dp[i], dp[j] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// console.log(&quot;=========&quot;);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// console.log(dp)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">dp);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lengthOfLIS</span><span style="color:#24292E;">(</span><span style="color:#E36209;">nums</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[])</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 动态规划，从大变小，每个元素都至少可以单独成为子序列，此时长度都为 1</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 声明数组dp，dp[i]的值代表 nums[i] 结尾的最长子序列长度</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> dp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">(nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">fill</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> i; j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// num[i]:当前项，nums[j]当前项的前一项</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果nums[i]大于nums[j]，nums[i] 可以接在 nums[j] 之后（因为要求严格递增【排除了相等等情况】），</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 此情况下最长子序列长度为 dp[j] + 1</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// console.log(i,j)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> nums[j]) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// console.log([10, 9, 2, 5, 3, 7, 21, 18], dp);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// console.log(\`i=\${i},nums[\${i}]=\${nums[i]},j=\${j},nums[\${j}]=\${nums[j]},dp[\${i}]=\${dp[i]},dp[\${j}]=\${dp[j]},dp[\${j}] + 1=\${dp[j] + 1}\`);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// console.log(\`因为Math.max(dp[\${i}], dp[\${j}] + 1)所以dp[\${i}]=\${Math.max(dp[i], dp[j] + 1)}\`);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// debugger</span></span>
<span class="line"><span style="color:#24292E;">        dp[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(dp[i], dp[j] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// console.log(&quot;=========&quot;);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// console.log(dp)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">dp);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>二分搜索法+位运算+贪心算法</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#E1E4E8;">nums</span><span style="color:#6A737D;"> </span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#F97583;">@returns</span><span style="color:#6A737D;"> </span></span>
<span class="line"><span style="color:#6A737D;"> * 复杂度分析</span></span>
<span class="line"><span style="color:#6A737D;"> * 时间复杂度：O(nlogn)</span></span>
<span class="line"><span style="color:#6A737D;"> * 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)</span></span>
<span class="line"><span style="color:#6A737D;"> * 空间复杂度：O(n)</span></span>
<span class="line"><span style="color:#6A737D;"> * tails需要额外空间</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lengthByDichotomy</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nums</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 维护一个数组 tails，其中每个元素 tails[k] 的值代表 长度为 k+1 的子序列尾部元素的值（k为自然数）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如tail[0]是求长度为1的连续子序列时的最小末尾元素</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 例：在 1 8 4中 tail[0]=1 tail[1]=4 没有tail[2] 因为无法到达长度为3的连续子序列</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始tails数组[0],其值为子序列列长度为1，即num[0]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 由于js数组的特点，可以不用初始化tails数组的长度，不用每个元素都初始化0---当然初始化也是可以的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> tails</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [nums[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]]    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设 result 为 tails 当前长度，代表直到当前的最长递增子序列长度</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从nums第二个元素开始遍历数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 比 tails[result] 大，则更新 tails[result]，同时 result++</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// console.log(i,result,nums[i] &gt; tails[result-1])</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nums[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> tails[result</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            tails[</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">result </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 否则，使用二分查找法，找到比 nums[i] 大的最小的 tails[j]，即tails[j]&lt;nums[i]&lt;tails[j+1]，然后更新 tails[j]</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 这里运用了位运算,为什么可以这么算呢?</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// &gt;&gt;相当于处于2</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//那这里为什么除以2呢？</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">//根据二分搜索法 基本原理：</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">                 * 首先将要查找的元素[key]与数组的中间元素比较</span></span>
<span class="line"><span style="color:#6A737D;">                 * 1、如果key元素小于中间元素，组需要在数组的前一半中继续查找</span></span>
<span class="line"><span style="color:#6A737D;">                 * 2、如果key和中间元素相等，匹配成功，查找结束</span></span>
<span class="line"><span style="color:#6A737D;">                 * 3、如果key大于中间元素，只需要在数组的后一般元素中继续查找key</span></span>
<span class="line"><span style="color:#6A737D;">                 */</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">mid</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// console.log(&quot;if (tails[mid] &lt; nums[i]) {&quot;,tails[mid],nums[i])</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (tails[mid] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums[i]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mid</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            tails[left] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// console.log(&#39;tails[left] = nums[i]&#39;,tails[left])</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 打印tails数组---不能等同于不同长度时对应的子序列，因为遇到小的数，会插在更前面，改变了在元素组的位置（证明用例[10, 9, 2, 5, 3, 7, 1, 18]中的1插入时）</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// console.log(tails)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#D73A49;">@param</span><span style="color:#6A737D;"> </span><span style="color:#24292E;">nums</span><span style="color:#6A737D;"> </span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#D73A49;">@returns</span><span style="color:#6A737D;"> </span></span>
<span class="line"><span style="color:#6A737D;"> * 复杂度分析</span></span>
<span class="line"><span style="color:#6A737D;"> * 时间复杂度：O(nlogn)</span></span>
<span class="line"><span style="color:#6A737D;"> * 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)</span></span>
<span class="line"><span style="color:#6A737D;"> * 空间复杂度：O(n)</span></span>
<span class="line"><span style="color:#6A737D;"> * tails需要额外空间</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lengthByDichotomy</span><span style="color:#24292E;">(</span><span style="color:#E36209;">nums</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[])</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 维护一个数组 tails，其中每个元素 tails[k] 的值代表 长度为 k+1 的子序列尾部元素的值（k为自然数）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如tail[0]是求长度为1的连续子序列时的最小末尾元素</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 例：在 1 8 4中 tail[0]=1 tail[1]=4 没有tail[2] 因为无法到达长度为3的连续子序列</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始tails数组[0],其值为子序列列长度为1，即num[0]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 由于js数组的特点，可以不用初始化tails数组的长度，不用每个元素都初始化0---当然初始化也是可以的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> tails</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [nums[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]]    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设 result 为 tails 当前长度，代表直到当前的最长递增子序列长度</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从nums第二个元素开始遍历数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 比 tails[result] 大，则更新 tails[result]，同时 result++</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// console.log(i,result,nums[i] &gt; tails[result-1])</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nums[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> tails[result</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">            tails[</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">result </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i]</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 否则，使用二分查找法，找到比 nums[i] 大的最小的 tails[j]，即tails[j]&lt;nums[i]&lt;tails[j+1]，然后更新 tails[j]</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> right) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 这里运用了位运算,为什么可以这么算呢?</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// &gt;&gt;相当于处于2</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//那这里为什么除以2呢？</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">//根据二分搜索法 基本原理：</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">                 * 首先将要查找的元素[key]与数组的中间元素比较</span></span>
<span class="line"><span style="color:#6A737D;">                 * 1、如果key元素小于中间元素，组需要在数组的前一半中继续查找</span></span>
<span class="line"><span style="color:#6A737D;">                 * 2、如果key和中间元素相等，匹配成功，查找结束</span></span>
<span class="line"><span style="color:#6A737D;">                 * 3、如果key大于中间元素，只需要在数组的后一般元素中继续查找key</span></span>
<span class="line"><span style="color:#6A737D;">                 */</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">mid</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> right) </span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// console.log(&quot;if (tails[mid] &lt; nums[i]) {&quot;,tails[mid],nums[i])</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (tails[mid] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums[i]) {</span></span>
<span class="line"><span style="color:#24292E;">                    left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mid</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            tails[left] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i]</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// console.log(&#39;tails[left] = nums[i]&#39;,tails[left])</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 打印tails数组---不能等同于不同长度时对应的子序列，因为遇到小的数，会插在更前面，改变了在元素组的位置（证明用例[10, 9, 2, 5, 3, 7, 1, 18]中的1插入时）</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// console.log(tails)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="vue3快速diff算法中的实现" tabindex="-1">Vue3快速Diff算法中的实现 <a class="header-anchor" href="#vue3快速diff算法中的实现" aria-label="Permalink to &quot;Vue3快速Diff算法中的实现&quot;">​</a></h2><p>注意：在快速Diff算法中，求解最长递增子序列的目的是对子节点重新编号，所以肯定不只是求解出长度即可。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getSequence</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[])</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">[] {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">p</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> arr.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">result</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i, j, u, v, c</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> arr.</span><span style="color:#79B8FF;">length</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> len; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">arrI</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> arr[i]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (arrI </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result[result.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (arr[j] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> arrI) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                p[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j</span></span>
<span class="line"><span style="color:#E1E4E8;">                result.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(i)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">continue</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            u </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">            v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (u </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> v) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (u </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> v) </span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (arr[result[c]] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> arrI) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    u </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (arrI </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> arr[result[u]]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (u </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    p[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result[u </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                result[u] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    u </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result.</span><span style="color:#79B8FF;">length</span></span>
<span class="line"><span style="color:#E1E4E8;">    v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> result[u </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (u</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        result[u] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> v</span></span>
<span class="line"><span style="color:#E1E4E8;">        v </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p[v]</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getSequence</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[])</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">[] {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">p</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">result</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i, j, u, v, c</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr.</span><span style="color:#005CC5;">length</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> len; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">arrI</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> arr[i]</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (arrI </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result[result.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (arr[j] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> arrI) {</span></span>
<span class="line"><span style="color:#24292E;">                p[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j</span></span>
<span class="line"><span style="color:#24292E;">                result.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(i)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">continue</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            u </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">            v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (u </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> v) {</span></span>
<span class="line"><span style="color:#24292E;">                c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (u </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> v) </span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (arr[result[c]] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> arrI) {</span></span>
<span class="line"><span style="color:#24292E;">                    u </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (arrI </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> arr[result[u]]) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (u </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    p[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result[u </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                result[u] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    u </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result.</span><span style="color:#005CC5;">length</span></span>
<span class="line"><span style="color:#24292E;">    v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> result[u </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (u</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        result[u] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> v</span></span>
<span class="line"><span style="color:#24292E;">        v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p[v]</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>分析：getSequence相比于解法二，思路相近。但除了求解出长度，还会回溯查找原数组的索引--通过维护数组p，p记录了当前位置元素arr[i]插入时，递增序列前一个元素的真实值。</p>`,26),t=[e];function c(E,y,i,u,F,A){return n(),a("div",null,t)}const r=s(o,[["render",c]]),d=Object.freeze(Object.defineProperty({__proto__:null,__pageData:p,default:r},Symbol.toStringTag,{value:"Module"}));export{d as _,p as __pageData,r as default};
