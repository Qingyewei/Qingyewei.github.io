import{_ as c,C as t,o,c as i,k as n,a as e,H as s,Q as p}from"./chunks/framework.12b7deed.js";const r=JSON.parse('{"title":"Vue3源码共读：第一期：源码学习方法分享，模块之间依赖关系，初始化整体流程分析","description":"","frontmatter":{"title":"Vue3源码共读：第一期：源码学习方法分享，模块之间依赖关系，初始化整体流程分析","head":[["meta",{"name":"og:title","content":"Vue3源码共读：第一期：源码学习方法分享，模块之间依赖关系，初始化整体流程分析 | VitePress"}]]},"headers":[],"relativePath":"vue3/source-code-to-1.md","filePath":"vue3/source-code-to-1.md","lastUpdated":1698918793000}'),d={name:"vue3/source-code-to-1.md"},m=p(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>看了村长的源码共读，觉得还是要以自己的一种方式来记录自己的学习，不然今天学明天忘，纯属瞎扯淡。</p><p>村长说：为什么学习源码？一共总结了四个点：面向工资、内卷、加深理解与增强解决的问题的能力、学习大佬的编程思想。学习源码能够很好的修炼内功，形成一个很好的学习圆满方式和思维，以后再去学习其他的源码时，就会轻松很多啊。这就相当于提升自己的内功一起，实际上自身的学习能力也会快速提高。</p><p>村长学习方法： 第一种：首先要有一条主线，要沿着一条线看下去，看见一个知识点之后有引出另一个知识点，又跑到另一个知识点了，这样会让你容易银企一个问题，你会陷进去源码森林的迷宫里头，很容易迷路。</p><p>第二种：画思维导图，可以下次再打开的时候，按着顺序学习</p><p>第三种：提出一个问题，去源码中找到答案</p><p>第四种：造一个轮子，譬如：大崔哥的mini-vue</p><p>那我们这次的主线是什么呢？在写vue的时候，肯会有有一个createApp的过程</p><p>很显然，这次的主线就是先看看这个createApp是如何创建的</p><h2 id="环境搭建" tabindex="-1">环境搭建 <a class="header-anchor" href="#环境搭建" aria-label="Permalink to &quot;环境搭建&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git clone git@github.com:vuejs</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">core.git</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git clone git@github.com:vuejs</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">core.git</span></span></code></pre></div><p>因为vue3的管理包已经更换了使用了<code>pnpm</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">npm i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">g pnpm</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">npm i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">g pnpm</span></span></code></pre></div><p>克隆下来的项目，首先要查看<code>package.json</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbc59cff12b34f7eba457ede2b995259~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc9effa3380a437bb8c2b6d19b8df646~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>将这个大包删掉，不然下载依赖的时候会比较慢</p><p>修改运行命令，添加 <code>--sourcemap</code><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cf4fc71898345b4ac98406d312c8d38~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>执行启动命令，跟下图一样则说明成功了：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c6eb91ea187478eb85a6ecbe5c4d7c6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="初始化流程分析" tabindex="-1">初始化流程分析 <a class="header-anchor" href="#初始化流程分析" aria-label="Permalink to &quot;初始化流程分析&quot;">​</a></h2><p>那接下来我们就可以测试了，怎么测试 刚才这个打包就可以调试呢，可以在这个路径下打开这个案例<code>packages\\vue\\examples\\composition\\todomvc.html</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c9407db5b454cadb8d9056c11a72ca9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在浏览器中打开这个案例,打开控制台，按<code>Ctrl+P</code>输入刚才打开的文件的名字寻找。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28e0617c232c4b2f8da64cf4f4f83ca4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>可以设置一个断点在这里，刷新页面：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b6fe70c0a8c4874bb9e55b451d2f2b3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>当我们点击继续执行的时候，会发现会跳转到了一个新的文件，路径为：<code>packages\\runtime-dom\\src\\index.ts</code>，可以看出creatApp是从这里来的</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8314749995cd443e9a61abf37083d96f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在源码中可以看出，上面这个方法是返回了一个app。</p><p>这个是执行mount <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b308bff28d6483da59040cfb16f5ba3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04e2ddfa90bd41348e74130551d1dc61~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这个时候我们又要去看一下<code>ensureRenderer</code>这个函数了得到一个渲染器<code>renderer</code>-<code>creatApp</code>。在vscode中可以直接按住Ctrl键，鼠标点击，就可以直接跳转了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d349ffc24a142baa1509b6fca96073b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"> 跳转发现又去执行了<code>createRenderer</code>，再跳转，这是后发现路径文件变为了：<code>packages\\runtime-core\\src\\renderer.ts </code><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f01bfd71afe249b4989b4928477525bc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>上图可以看出在去执行了<code>baseCreateRenderer</code>，这个时候跳转，你会发现它是个TS函数重载的，vue3最大的函数。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ce745aab054d9290b3210c9aa047c4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>整体的内容2000多行代码就很多。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723e30a481d148eaa2dd440b0927319a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"> 会发现<code>baseCreateRenderer</code>返回的是一个对象，对象里面有三个内容。<code>render：</code>就是我我们所说的渲染函数，通过patch虚拟DOM和diff算法最后渲染上树的一个过程。<code>hydrate：</code>是SSR渲染的。这次我们主要看的是<code>createApp</code>，它是<code>createAppAPI</code>的返回，再跳转路径为：<code>packages\\runtime-core\\src\\apiCreateApp.ts</code></p><p>通过creatApp里面的对象内容传进来的，会被理解成为一个根组件，vue2是接受到的组件的配置对象，vue3直接理解为根组件配置对象或者组件实例，调用组件实例的render()，得到vnode通过patch的diff算法，再转化成DOM树</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80a9aea835584cd685d7d687a7501d8e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这个就是App实例，<code>app-mount</code>创建根组件的虚拟DOM，只执行一次，通过传进来的<code>render</code>函数，渲染vnode到dom追加到根元素rootContainer上</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62e843a9947e42b68c8abe8c0ec04da5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这时候要回到<code>packages\\runtime-core\\src\\renderer.ts</code>的<code>baseCreateRenderer</code>，查看<code>render</code>函数的来源，首次渲染，首次执行根组件的vndoe 作为patch函数参数二，参数一是null，会执行挂载</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a351fd4ec6e452da7c660949e7005f3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"> 很显然我们执行的<code>else</code>里面的<code>patch</code>,跳转到patch函数，初始化执行的是patch中这段：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52920b90d9294b80bcbc59a46a467bb7~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>再跳转<code>processComponent</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51e38eaa8ba64faca3d7ce54defbd0e0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>需要再跳转<code>mountComponent</code>，首次挂载根组件，以后还会执行因为还会有其他子组件了。</p><p>组价挂载过程： 1、组件实例 2、初始化组件实例、插槽、数据等。<code>setupComponent</code> 3、获取vnode。<code>setupRenderEffect</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02c87f68287419cbb063f990a6c7c43~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这里方法中有个初始化组件的方法<code>setupComponent</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f7813a5953f468c9a2ace111b466832~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>再跳<code>setupComponent</code>。这个时候路径已经发现了改变了：<code>packages\\runtime-core\\src\\component.ts</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18353b710bd6430bbe9451a5ff41b03e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>再跳<code>setupStatefulComponent</code>，初始化setup添加响应式</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c3c88f3fa054abb906eec04e5195c4d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>会再执行<code>finishComponentSetup</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b906349f8db8493ba6d1053cb61c41a4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"> 这里就可以解释为什么有些组件没有render函数但是也会渲染出来的原因了</p><p>在<code>mountComponent</code>中还会执行另外一个方法<code>setupRenderEffect</code></p><p>1、创建一个组件的更新函数 <code>componentUpdateFn</code></p><pre><code>1-1、render获取Vnode
1-2、patch（oldVnode，vnode）
</code></pre><p>2、创建更新机制 new ReactiveEffect（更新函数）</p><p>3、首次执行<code>update</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/345aa53a7bcb46e29bd436ebe1af587f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>将将vnode转为DOM</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c5ef8b3734aa8b6c32dbbdbd18783~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="提出问题-渲染器是什么-作用是什么" tabindex="-1">提出问题：渲染器是什么，作用是什么？ <a class="header-anchor" href="#提出问题-渲染器是什么-作用是什么" aria-label="Permalink to &quot;提出问题：渲染器是什么，作用是什么？&quot;">​</a></h2>`,67),b=p('<p>作用：首次渲染、获取应用程序的实例</p><h2 id="提出问题-挂载做了什么事情" tabindex="-1">提出问题：挂载做了什么事情？ <a class="header-anchor" href="#提出问题-挂载做了什么事情" aria-label="Permalink to &quot;提出问题：挂载做了什么事情？&quot;">​</a></h2><p>只执行一次、初始化看到第一次渲染结果、建立更新机制（不停循环）</p><h2 id="提出问题-组件不一定有渲染函数-但是一定会渲染出来-这是为什么呢" tabindex="-1">提出问题：组件不一定有渲染函数，但是一定会渲染出来，这是为什么呢？ <a class="header-anchor" href="#提出问题-组件不一定有渲染函数-但是一定会渲染出来-这是为什么呢" aria-label="Permalink to &quot;提出问题：组件不一定有渲染函数，但是一定会渲染出来，这是为什么呢？&quot;">​</a></h2><p>这就是编译器，因为那个编译器其实可以把当前这个组件所挂载的那个目标里面的内容，给它当成一段HTML代码把它编译成渲染函数</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>手动记录一下，方便下次学习</p>',7);function f(l,u,k,h,v,j){const a=t("App");return o(),i("div",null,[m,n("p",null,[e("渲染器是个对象，一个是renderer的方法：react中有个React.render("),s(a),e(',"#app")是一样的功能，它把接收到的虚拟DOM转换成DOM对象，追加到宿主元素上去。一个是hydrate的方法，服务端SSR渲染，将一个虚拟DOM直接生成HTML字符串。一个creatApp的方法：创建app实例，是通过ceartAppApi这个工厂函数返回的')]),b])}const g=c(d,[["render",f]]),y=Object.freeze(Object.defineProperty({__proto__:null,__pageData:r,default:g},Symbol.toStringTag,{value:"Module"}));export{y as _,r as __pageData,g as default};
