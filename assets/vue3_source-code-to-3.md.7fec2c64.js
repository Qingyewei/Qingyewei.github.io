import{_ as e,o as p,c as t,Q as c}from"./chunks/framework.12b7deed.js";const a=JSON.parse('{"title":"Vue3源码共读：第三期：从patch根组件到首次渲染DOM树过程分析","description":"","frontmatter":{"title":"Vue3源码共读：第三期：从patch根组件到首次渲染DOM树过程分析","head":[["meta",{"name":"og:title","content":"Vue3源码共读：第三期：从patch根组件到首次渲染DOM树过程分析 | VitePress"}]]},"headers":[],"relativePath":"vue3/source-code-to-3.md","filePath":"vue3/source-code-to-3.md","lastUpdated":1698918793000}'),o={name:"vue3/source-code-to-3.md"},i=c('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>这次主要是沿着patch这条线继续往下走，当第一次patch-component向下走的时候 最后一定会递归，直到把整棵树全部给他渲染出来，最终展现在面前的组件内的元素。</p><h2 id="首次patch" tabindex="-1">首次patch <a class="header-anchor" href="#首次patch" aria-label="Permalink to &quot;首次patch&quot;">​</a></h2><p>首次<code>patch</code>的时候，我们进来的执行的是<code>processComponent</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aba29fa8bae438b89394226e77abf0a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在<code>processComponent</code>中由于第一次是n1还是空的，所以我们接下来执行的是<code>mountComponent</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79d6a737eb4c495cad450569351a4921~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在<code>mountComponent</code>做了什么呢？根组件创建过程</p><p>1、创建组件实例 <code>compatMountInstance</code></p><p>2、初始化组件实例 <code>setupComponent</code></p><ul><li>setup - 编译render选项</li><li>applyOptions</li></ul><p>3、获取vnode <code>setupRenderEffect</code></p><ul><li>创建一个组件更新函数 <ul><li>render获得vnode</li><li>patch(oldVnode，vnode)</li></ul></li><li>创建更新机制： new ReactiveEffect(更新函数)</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/961d1c27411f4e3c8db59141d0c1c386~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在 <code>setupRenderEffect</code>中，有两个作用创建一个组件更新函数、创建更新机制</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf06a64942c4f99aec51d9b4cbafc5e~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在<code>componentUpdateFn</code>中首次执行<code>instance.isMounted</code>是<code>false</code>，执行的是接下里的这段的</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6114e6523e4ed8896ad37aec86c93b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="再次patch" tabindex="-1">再次patch <a class="header-anchor" href="#再次patch" aria-label="Permalink to &quot;再次patch&quot;">​</a></h2><p>这个时候进来我们执行的不是<code>processComponent</code>，而是<code>processElement</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75624655cd434740bad99be93c7e4ee6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在processElement中，执行的是<code>mountElement</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b802b3dcd874418fbd3cde0df7919d17~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在mountElement中创建真实的DOM</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18b2e52f2444536b7f5805d5e88df3b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>hostCreateElement就是创建真实DOM的方法，他来自<code>createRenderer</code>给<code>baseCreateRenderer</code>传入的，</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93c99bb08d8b448d90496e656692f0df~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来就是这个，设置某个节点的文本内容</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b8acbdf3d432e862a41fb46be8cce~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这里可能会发生递归的，因为如果说我们还有子元素等，就会去执行<code>mountChildren</code>而不是hostSetElementText</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a262d19b49a4b0595b343030f8a61a1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>设置元素class、id</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a03154cfab8458ca777e06ed4ef41ac~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>追加到父元素上<code>hostInsert</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53265da847c64271a5e5253ccc6f5228~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这样页面就可以出来了</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdeddc9fc1764ed2868592c0e96442bf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>知识是重复的，但是内容更细了</p>',39),n=[i];function d(r,s,f,l,u,b){return p(),t("div",null,n)}const m=e(o,[["render",d]]),h=Object.freeze(Object.defineProperty({__proto__:null,__pageData:a,default:m},Symbol.toStringTag,{value:"Module"}));export{h as _,a as __pageData,m as default};
