import{_ as e,o as t,c as a,Q as p}from"./chunks/framework.12b7deed.js";const c=JSON.parse('{"title":"Vue3源码共读：第四期：DOM和组件属性初始化过程，更新整体流程解析","description":"","frontmatter":{"title":"Vue3源码共读：第四期：DOM和组件属性初始化过程，更新整体流程解析","head":[["meta",{"name":"og:title","content":"Vue3源码共读：第四期：DOM和组件属性初始化过程，更新整体流程解析 | VitePress"}]]},"headers":[],"relativePath":"vue3/source-code-to-4.md","filePath":"vue3/source-code-to-4.md","lastUpdated":1698918793000}'),r={name:"vue3/source-code-to-4.md"},o=p('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>上次我们熟悉了从patch根组件到首次渲染DOM树过程分析。遗漏的一个问题，hostCreateElement哪里来呢？节点属性如何初始化？DOM操作哪里来？ 本次就来倒退一下啊，他到底是从哪里来</p><h2 id="ensurerenderer" tabindex="-1">ensureRenderer <a class="header-anchor" href="#ensurerenderer" aria-label="Permalink to &quot;ensureRenderer&quot;">​</a></h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3410c64930014765904a842c5f705abe~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>从ensureRenderer中可以看到传入的options</p><p>nodeOps就是节点操作</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6ad2a2403004848b1f94df46fc4807b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这个就是DOM操作的来源</p><h2 id="节点属性来源" tabindex="-1">节点属性来源 <a class="header-anchor" href="#节点属性来源" aria-label="Permalink to &quot;节点属性来源&quot;">​</a></h2><p>分两种情况，有DOM和组件</p><h3 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d42bd813be44b6ad9baead8586fe52~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>接下来回执行的是<code>patchDOMProp</code>而并不是<code>patchAttr</code>，<code>patchAttr</code>在<code>&lt;input v-model type=&quot;checkbox&quot;&gt;</code> 时才会执行</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a4e392388274b66bb5e472601694af3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h3><p>组件的话，就要回到熟悉的patch函数，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2b927f742de4f9eaf566d802d6928ce~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>最后在我们的setupCompontent中就可以发现组件初始化的方法<code>initProps</code><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52dc6ae9722e4033881036394ad231b0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>来看看<code>initProps</code>的内容</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29cdd316c6d48d3a48da8f0244f462f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>setFullProps的内容</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e36237bf45f34bcfb7982cd9bdde90b8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>那他怎么去更新的呢？我有首次初始化中y有个非常重要的更新机制就是<code>setupRenderEffect</code></p><h2 id="setuprendereffect" tabindex="-1">setupRenderEffect <a class="header-anchor" href="#setuprendereffect" aria-label="Permalink to &quot;setupRenderEffect&quot;">​</a></h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aacfff43bc534fc1a47bf3f77440cd85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>更新的时候的操作</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d426b783cca34587bdf6819fa4c2d662~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>patch执行后，最后关键的执行</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538208f776d2464cb57a1fded27e5432~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91bcbd0eaf384fc2bb634900cb8e8954~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>',31),i=[o];function n(d,s,m,u,b,l){return t(),a("div",null,i)}const f=e(r,[["render",n]]),h=Object.freeze(Object.defineProperty({__proto__:null,__pageData:c,default:f},Symbol.toStringTag,{value:"Module"}));export{h as _,c as __pageData,f as default};
