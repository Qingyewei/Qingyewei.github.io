import{_ as e,o as t,c as a,Q as p}from"./chunks/framework.12b7deed.js";const c=JSON.parse('{"title":"Vue3源码共读：第五期：数据响应式原理，reactive响应式和依赖收集过程（上）","description":"","frontmatter":{"title":"Vue3源码共读：第五期：数据响应式原理，reactive响应式和依赖收集过程（上）","head":[["meta",{"name":"og:title","content":"Vue3源码共读：第五期：数据响应式原理，reactive响应式和依赖收集过程（上） | VitePress"}]]},"headers":[],"relativePath":"vue3/source-code-to-5-1.md","filePath":"vue3/source-code-to-5-1.md","lastUpdated":1698918793000}'),i={name:"vue3/source-code-to-5-1.md"},o=p('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>在vue3中 数据响应式原理，reactive响应式和依赖收集 的过程是怎么样的呢，这是本次的主题。</p><p>那什么是数据响应式呢？</p><p>首先这个数据要怎么才能知道变化了，这时候后需要一个机制，能够侦测到这个数据的变化，响应这个数据的变化到视图上</p><p>第一：为什么需要这个数据响应式</p><p>vue是声明式开发，用户只需关心结果不需关心过程，带来最大的好处就是<strong>数据驱动</strong>，将来只管状态，不需要管具体的操作（DOM操作）。</p><p><code>setupRenderEffect</code>作用当render函数内部响应式数据发生变化，副作用再次执行。</p><p>那这个数据时怎么做到响应式的，是什么时候添加上响应式的？</p><h2 id="添加响应式" tabindex="-1">添加响应式 <a class="header-anchor" href="#添加响应式" aria-label="Permalink to &quot;添加响应式&quot;">​</a></h2><p>那什么时候初始化给数据添加上响应式的呢？这就要回到<code>mountComponent</code>找到我们的下面这句</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b91885423c24a8cad6ddcc5665da680~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在setupComponent的我们有提过，里面有给数据做响应式。具体就是在apllyOptions中对data、props、watch、methods、computed</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/221fcca421bb4440bd0916b494ec57b8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>那来看看<code>apllyOptions</code>吧</p><p>处理data数据</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f234ef8d3fd47edbfbb935e6a50acb9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="reactive" tabindex="-1">reactive <a class="header-anchor" href="#reactive" aria-label="Permalink to &quot;reactive&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6b59a77b75484da3af37579254a1b3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>创建响应式对象 <code>createReactiveObject</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd394e12e4d547a8b0718200e0b8d804~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>new Proxy的方法从哪里来呢？是通过参数传进来的，沿着往回找</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/768e9153aed24422bd44836846d4b604~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>最后找到mutableHandlers</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d94875140114a22b7314b7aa92a3529~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这样我就能随时知道这个值发生了改变，知道了之后就要就行依赖收集，触发更新</p><h2 id="依赖收集" tabindex="-1">依赖收集 <a class="header-anchor" href="#依赖收集" aria-label="Permalink to &quot;依赖收集&quot;">​</a></h2><p>上面的get是由createGetter生成的，默认情况下，创一个可变不是只读，且是深层响应式对象</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bdc9bb3a4794b76b13941639eff3e12~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>依赖收集如何做呢？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67ca8c9f580b4af0ae805e1fee396a9a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>如何创建依赖关闭</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/634aab9cdf24400eb15ec93704d2302a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>那什么时候回触发get的呢？就是当我们在template中使用<code>.</code>的时候，譬如<code>this.value</code></p><p>最后打印的的时候的<code>activeEffect</code>其实就是我们的</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0e9af5b3695409fa98761d52488d572~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>走走停停 又回到原处了</p>',37),r=[o];function m(s,d,b,f,u,l){return t(),a("div",null,r)}const n=e(i,[["render",m]]),h=Object.freeze(Object.defineProperty({__proto__:null,__pageData:c,default:n},Symbol.toStringTag,{value:"Module"}));export{h as _,c as __pageData,n as default};
